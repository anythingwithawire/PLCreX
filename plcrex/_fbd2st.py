#
# This file is part of PLCreX (https://github.com/marwern/PLCreX).
#
# Copyright (c) 2022 Marcel Werner.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#
from plcrex import _xml_checker, _st2tree, _iec_checker, _fbd_io_checker
from pathlib import Path
import xml.etree.ElementTree as ET
import pprint


def translation(src: Path,
                iec_check: bool = False,
                bwd: bool = False,
                formal: bool = False,
                st_parser: bool = False,
                impact_analysis : bool = False):
    pp = pprint.PrettyPrinter(indent=2)
    informal = not formal

    # open PLCopen xml file
    root = ET.parse(src).getroot()

    def write_interface():
        print('\n*** add interfaces / local variables without IDs ***')
        # inputs
        write_var_x("inputVars")
        # outputs
        write_var_x("outputVars")
        # local variables (without additional port variables)
        write_var_x("localVars")

    def write_var_x(var_type):
        tmp_str = ""
        tmp_var_type = var_type
        if var_type == "localVars":
            tmp_var_type = "local"
        elif var_type == "inputVars":
            tmp_var_type = "input"
        elif var_type == "outputVars":
            tmp_var_type = "output"

        for i1 in root.iter('{http://www.plcopen.org/xml/tc6_0201}interface'):
            for i2 in i1:
                # tmp list due to { ... } prefix
                tmp1 = i2.tag.split('}')
                print(tmp1[1] + ':')  # Debug
                # add xVars
                if tmp1[1] == var_type:
                    if var_type == "localVars":
                        st_file.write('\tVAR\n')
                    elif var_type == "inputVars":
                        st_file.write('\tVAR_INPUT\n')
                    elif var_type == "outputVars":
                        st_file.write('\tVAR_OUTPUT\n')

                    for i3 in i2.iter('{http://www.plcopen.org/xml/tc6_0201}variable'):
                        for i4 in i3.find('{http://www.plcopen.org/xml/tc6_0201}type'):
                            # tmp list due to { ... } prefix
                            tmp2 = i4.tag.split('}')

                            # only possible for localVars
                            if var_type == "localVars":
                                # if derived data type, get('name'), for example: <derived name="TON"/>
                                if tmp2[1] == 'derived':
                                    tmp2[1] = i4.get('name')

                            # check if variable is a function block instance
                            # with ini
                            if i3.find('{http://www.plcopen.org/xml/tc6_0201}initialValue') is not None:
                                for i5 in i3.find('{http://www.plcopen.org/xml/tc6_0201}initialValue'):
                                    tmp_str = i3.get('name') + ' : ' + tmp2[1] + ' := ' + i5.get('value') + ';'
                                    interfaces.append({"var": i3.get('name'),
                                                       "data_type": tmp2[1],
                                                       "ini": i5.get('value'),
                                                       "dir": tmp_var_type})
                            # without ini
                            else:
                                tmp_str = i3.get('name') + ' : ' + tmp2[1] + ';'
                                interfaces.append({"var": i3.get('name'),
                                                   "data_type": tmp2[1],
                                                   "dir": tmp_var_type})
                            st_file.write('\t\t' + tmp_str + '\n')
                            print(tmp_str)

                    # don't print end of localVars section because later additional port variables will be added
                    if var_type != "localVars":
                        st_file.write('\tEND_VAR\n')

    def write_header(plc_pou_type):
        st_file.write(''
                      '//--- This file was generated by PLCreX ---\n'
                      '//--- https://github.com/marwern/PLCreX ---\n'
                      '//-----------------------------------------\n\n')

        # add POU type
        print('\n*** add POU type ***')
        for i1 in root.iter('{http://www.plcopen.org/xml/tc6_0201}pou'):
            pou_type = i1.get('pouType')
            pou_name = i1.get('name')
            print(pou_type, pou_name)

            if pou_type == 'functionBlock':
                plc_pou_type = "FUNCTION_BLOCK"
            elif pou_type == 'program':
                plc_pou_type = "PROGRAM"
            elif pou_type == 'function':
                plc_pou_type = "FUNCTION"
            st_file.write(plc_pou_type + ' ' + pou_name + '\n')

    def create_block_comp_dict():
        print('\n*** create block_comp dictionary ***')
        for i1 in root.iter('{http://www.plcopen.org/xml/tc6_0201}block'):
            # reset lists in every loop
            input_variables_list = []
            output_variables_list = []

            # check if block component represents a POU instance
            if i1.get('instanceName') is not None:
                print('instanceName: ' + i1.get('instanceName'))  # Debug

                # Inputs
                for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}inputVariables'):
                    # for each input
                    for i3 in i2.iter('{http://www.plcopen.org/xml/tc6_0201}variable'):
                        for i4 in i3.iter('{http://www.plcopen.org/xml/tc6_0201}connection'):
                            if i4.get('formalParameter'):
                                input_variables_list.append({"formalParameter": i3.get('formalParameter'),
                                                             "refLocalId": i4.get('refLocalId'),
                                                             "formalParameter_port": i4.get('formalParameter')})
                            else:
                                input_variables_list.append({"formalParameter": i3.get('formalParameter'),
                                                             "refLocalId": i4.get('refLocalId'),
                                                             "formalParameter_port": i4.get('formalParameter')})

                # Outputs
                for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}outputVariables'):
                    # for each output
                    for i3 in i2.iter('{http://www.plcopen.org/xml/tc6_0201}variable'):
                        output_variables_list.append({"formalParameter": i3.get('formalParameter')})

                # append dictionary
                tmp = {"localId": i1.get('localId'),
                       "instanceName": i1.get('instanceName'),
                       "inputVariables": input_variables_list,
                       "outputVariables": output_variables_list,
                       "executionOrderId": i1.get('executionOrderId')}
                block_comp.append(tmp)
                pp.pprint(tmp)

            # check if block component represents a library function [block]
            elif i1.get('typeName') is not None:
                print('typeName: ' + i1.get('typeName'))  # Debug

                # Inputs
                for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}inputVariables'):
                    # for each input
                    for i3 in i2.iter('{http://www.plcopen.org/xml/tc6_0201}variable'):
                        for i4 in i3.iter('{http://www.plcopen.org/xml/tc6_0201}connection'):
                            if i4.get('formalParameter'):
                                print('inputVariables = {formalParameter: ' + i3.get(
                                    'formalParameter') + ', refLocalId: ' + i4.get(
                                    'refLocalId') + ', formalParameter_port: ' + i4.get(
                                    'formalParameter') + '}')  # Debug

                                input_variables_list.append(
                                    {"formalParameter": i3.get('formalParameter'),
                                     "refLocalId": i4.get('refLocalId'),
                                     "formalParameter_port": i4.get('formalParameter')})

                            else:
                                input_variables_list.append({"formalParameter": i3.get('formalParameter'),
                                                             "refLocalId": i4.get('refLocalId')})

                # Outputs
                for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}outputVariables'):
                    # for each output
                    for i3 in i2.iter('{http://www.plcopen.org/xml/tc6_0201}variable'):
                        print('outputVariables = {formalParameter: ' + i3.get(
                            'formalParameter') + ', newVariable: ' + i1.get('typeName') + i1.get(
                            'localId') + "_" + i3.get(
                            'formalParameter') + '}')
                        output_variables_list.append(
                            {"formalParameter": i3.get('formalParameter'),
                             "newVariable": i1.get('typeName') + i1.get('localId') + "_" + i3.get('formalParameter')})

                # append dictionary
                tmp = {"localId": i1.get('localId'),
                       "typeName": i1.get('typeName'),
                       "inputVariables": input_variables_list,
                       "outputVariables": output_variables_list,
                       "executionOrderId": i1.get('executionOrderId')}
                block_comp.append(tmp)
                pp.pprint(tmp)

    def create_interface_with_id():
        print('\n*** create interface (with IDs) dictionary ***')

        # read inVariable
        for i1 in root.iter('{http://www.plcopen.org/xml/tc6_0201}inVariable'):
            for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}expression'):
                interfaces_with_ids.append({"localId": i1.get('localId'),
                                            "expression": i2.text,
                                            "dir": "inVariable"})
                print(i2.text, 'localId', i1.get('localId'), "inVariable")  # Debug

        # read outVariable
        for i1 in root.iter('{http://www.plcopen.org/xml/tc6_0201}outVariable'):
            tmp_name = ""
            tmp_ref_local_id = ""
            tmp_formal_parameter = ""

            # get expression, for instance <expression>LocalVar1</expression>
            for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}expression'):
                tmp_name = i2.text

            # get connectionPointIn, for instance <connection refLocalId="4" formalParameter="OUT">
            for i2 in i1.iter('{http://www.plcopen.org/xml/tc6_0201}connection'):
                tmp_ref_local_id = i2.get("refLocalId")
                tmp_formal_parameter = i2.get("formalParameter")

            print(tmp_name, 'localId', i1.get('localId'), "outVariable", tmp_ref_local_id, tmp_formal_parameter)
            interfaces_with_ids.append({"localId": i1.get('localId'),
                                        "expression": tmp_name,
                                        "dir": "outVariable",
                                        "refLocalId": tmp_ref_local_id,
                                        "formalParameter": tmp_formal_parameter})

    def create_fbd_connections():
        print('\n*** get function block port connections ***')  # Debug
        for dict_pou in block_comp:
            # reset arguments list
            arguments = []

            # check if dict_pou is a non instantiated function block
            if dict_pou.get("typeName") is not None:
                fbd_type = "typeName"
                print("typeName: " + dict_pou[fbd_type] + ':')
                for input_variable in dict_pou["inputVariables"]:
                    print(input_variable)

                    # check if POU/FB input_variable port is connected to interface / local variables
                    for inst in interfaces_with_ids:
                        if input_variable["refLocalId"] == inst["localId"]:
                            print("..connected to interface / local variables")
                            tmp = inst["expression"]
                            print(tmp)
                            arguments.append(tmp)

                    # check if POU/FB input_variable port is connected to other POU/FB output port
                    for inst in block_comp:
                        if input_variable["refLocalId"] == inst["localId"]:
                            if dict_pou.get("typeName"):  # instanceName
                                # non instantiated function block
                                if inst.get("instanceName") is None:
                                    print("..connected to other POU/FB output port")
                                    tmp = inst["typeName"] + inst["localId"] + '_' + input_variable[
                                        "formalParameter_port"]
                                # instantiated function block
                                else:
                                    print("..connected to other POU/FB output port")
                                    tmp = inst["instanceName"] + '.' + input_variable["formalParameter_port"]
                                print(tmp)
                                arguments.append(tmp)
                for output in dict_pou["outputVariables"]:
                    stats.append(output["newVariable"] + ' := ' + dict_pou["typeName"] + '(' + ','.join(
                        str(e) for e in arguments) + ');')  # convert list to string with separator ','

                    # TODO: still needed? to investigate
                    # get datatype for new local variable which has to be declared
                    # data_type = ""
                    # for var in interfaces:
                    #    if var.get("var") == dict_pou.get("typeName"):
                    #        variables_to_declare.append({
                    #            "typeName": dict_pou.get("typeName"),
                    #            "localId": dict_pou.get("localId"),
                    #            "formalParameter": dict_pou.get("formalParameter"),
                    #            "type": "DUMMY"})

            # check if dict_pou is a instantiated function block
            elif dict_pou.get("instanceName") is not None:
                fbd_type = "instanceName"
                print("instanceName: " + dict_pou[fbd_type] + ':')
                for input_variable in dict_pou["inputVariables"]:
                    print(input_variable)  # Debug

                    # check if POU/FB input_variable port is connected to interface / local variables
                    for inst in interfaces_with_ids:
                        if input_variable["refLocalId"] == inst["localId"]:
                            if informal:
                                tmp = inst["expression"]
                            else:
                                tmp = input_variable["formalParameter"] + ' := ' + inst["expression"]
                            print(tmp)
                            arguments.append(tmp)

                    # check if POU/FB input_variable port is connected to other POU/FB output port
                    for inst in block_comp:

                        if input_variable["refLocalId"] == inst["localId"]:
                            # connected to instantiated function block
                            if inst.get("instanceName"):
                                if informal:
                                    tmp = inst["instanceName"] + '.' + \
                                          input_variable[
                                              "formalParameter_port"]
                                else:
                                    tmp = input_variable["formalParameter"] + ' := ' + inst["instanceName"] + '.' + \
                                          input_variable[
                                              "formalParameter_port"]
                                print(tmp)
                                arguments.append(tmp)

                            # connected to non instantiated function block
                            elif inst.get("typeName"):
                                if informal:
                                    tmp = inst["typeName"] + inst.get(
                                        "localId") + '_' + \
                                          input_variable["formalParameter_port"]
                                else:
                                    tmp = input_variable["formalParameter"] + ' := ' + inst["typeName"] + inst.get(
                                        "localId") + '_' + \
                                          input_variable["formalParameter_port"]
                                print(tmp)
                                arguments.append(tmp)
                                variables_to_declare.append({
                                    "typeName": inst.get("typeName"),
                                    "localId": inst.get("localId"),
                                    "formalParameter": input_variable["formalParameter_port"],
                                    "type": "BOOL"})  # TODO true for most cases like AND, OR, NOT, EQ, LT, ...

                # generate list of fbd statements
                stats.append(dict_pou["instanceName"] + '(' + ','.join(
                    str(e) for e in arguments) + ');')  # convert list to string with separator ','

    def create_output_connections():
        # global tmp_stat
        tmp_stat = ""
        print('\n*** get output variable connections ***')  # Debug
        for outVar in interfaces_with_ids:
            if outVar.get("dir") == "outVariable":

                tmp_finding = False
                # find connected input
                for inVar in interfaces_with_ids:
                    if inVar.get("dir") == "inVariable":
                        # check if connection has been found
                        if outVar.get("refLocalId") == inVar.get("localId"):
                            tmp_finding = True
                            stats.append(outVar.get("expression") + ' := ' + inVar.get("expression") + ';')

                # find connected block output (if not connected to input_variable variable)
                if not tmp_finding:
                    for block in block_comp:
                        if outVar.get("refLocalId") == block.get("localId"):
                            if block.get("instanceName") is not None:
                                tmp_stat = outVar.get("expression") + ' := ' + block.get(
                                    "instanceName") + '.' + outVar.get(
                                    "formalParameter") + ';'
                            if block.get("typeName") is not None:
                                tmp_stat = outVar.get("expression") + ' := ' + block.get("typeName") + block.get(
                                    "localId") + '_' + outVar.get("formalParameter") + ';'

                                # get datatype for new local variable which has to be declared
                                for var in interfaces:
                                    if var.get("var") == outVar.get("expression"):
                                        variables_to_declare.append({
                                            "typeName": block.get("typeName"),
                                            "localId": block.get("localId"),
                                            "formalParameter": outVar.get("formalParameter"),
                                            "type": var.get("data_type")})
                            print(tmp_stat)
                            stats.append(tmp_stat)

    def write_add_variables():
        print('\n*** add new local variables ***')

        if not bwd:
            for var in variables_to_declare:
                tmp = var.get("typeName") + var.get("localId") + '_' + var.get("formalParameter") + ' : ' + var.get(
                    "type") + ';'
                st_file.write('\t\t' + tmp + '\n')
                print(tmp)
        st_file.write('\t' + "END_VAR\n\n")

    def get_pou_name():
        pou_type_plc = "unknown"
        for i1 in root.iter('{http://www.plcopen.org/xml/tc6_0201}pou'):
            pou_type = i1.get('pouType')
            pou_name = i1.get('name')
            print(pou_type, pou_name)

            if pou_type == 'functionBlock':
                pou_type_plc = "FUNCTION_BLOCK"
            elif pou_type == 'program':
                pou_type_plc = "PROGRAM"
            elif pou_type == 'function':
                pou_type_plc = "FUNCTION"
        return pou_type_plc

    # add stored statements (forward/backward translation strategy)
    def write_refactored_statements():
        if not bwd:
            for stat in stats:
                st_file.write('\t' + stat + '\n')

        # add stored statements (backward translation strategy)
        elif bwd:
            print('\n*** add stored statements (backward translation strategy) ***')

            print("\n".join(stats))
            stats_new_str = "\n".join(stats)

            print("\n*** inline method refactoring ***")
            stats_refactored = []
            for var in variables_to_declare:
                tmp_var_name = var.get("typeName") + var.get("localId") + '_' + var.get("formalParameter")

                # for each statement get assignment to new variables, where stats_new_str will be updated in each loop
                for stat1 in stats_new_str.splitlines():
                    tmp1 = stat1.split(" := ", 1)
                    if len(tmp1) >= 2:
                        if tmp_var_name == tmp1[0]:
                            print(tmp_var_name + "|--->" + tmp1[1])
                            # replace all occurrence in statements
                            stats_new_str = stats_new_str.replace(tmp_var_name, tmp1[1][:-1])
                            print(stats_new_str)

                # remove statement, when <A> := <A>;
                print("\n*** remove statements, when <A> := <A>; ***")
                stats_new_list = stats_new_str.splitlines()
                stats_refactored = []
                for e in stats_new_list:
                    if " := " in e:
                        if e.split(" := ")[0] == e.split(" := ")[1][:-1]:
                            print(">>ignore: " + e)
                        else:
                            print(">>add: " + e)
                            stats_refactored.append(e)
                    # is only needed if backward translation is selected because then smart view (without :=) is active
                    else:
                        print(">>add: " + e)
                        stats_refactored.append(e)

            if len(variables_to_declare) == 0:
                for stat in stats:
                    st_file.write('\t' + stat + '\n')
            else:
                for stat in stats_refactored:
                    st_file.write('\t' + stat + '\n')

    # create ST file
    with open(fr'.\exports\st\{Path(src).name}_{bwd}_{formal}_{iec_check}_{st_parser}_{impact_analysis}.st', 'w') as st_file:
        interfaces = []  # interfaces without localIds
        interfaces_with_ids = []  # interfaces with localIds
        block_comp = []  # block components
        stats = []  # statements to write
        variables_to_declare = []  # additional variables to declare
        informal = not formal

        # validate xml file
        _xml_checker.validate(src, "tc6_xml_v201.xsd")

        print('\n*** FBD-to-ST translation started ***\n\n')

        # write header
        write_header(get_pou_name())

        # write interface (+ local variables) without IDs
        write_interface()

        # create block_comp dictionary
        create_block_comp_dict()

        # sort block_comp dict according to executionOrderId
        block_comp = sorted(block_comp, key=lambda x: x["executionOrderId"])

        # create interfaces (with IDs)
        create_interface_with_id()

        # create function block port connections
        create_fbd_connections()

        # create output variable connections
        create_output_connections()

        # write additional local variables
        write_add_variables()

        # add stored statements (forward/backward translation strategy)
        write_refactored_statements()

        # EOF
        st_file.write("END_" + get_pou_name())
        print('\n***\n\n')

    # read ST file
    written_file = open(fr'.\exports\st\{Path(src).name}_{bwd}_{formal}_{iec_check}_{st_parser}_{impact_analysis}.st', 'r')
    print(written_file.read())

    print('\n*** FBD-to-ST translation finished ***\n\n')

    # bwd formal iec st2tree
    if iec_check:
        _iec_checker.execution(Path(fr'.\exports\st\{Path(src).name}_{bwd}_{formal}_{iec_check}_{st_parser}_{impact_analysis}.st'), '--verbose')

    if st_parser:
        _st2tree.translation(Path(fr'.\exports\st\{Path(src).name}_{bwd}_{formal}_{iec_check}_{st_parser}_{impact_analysis}.st'), True, True, False)

    if impact_analysis:
        _fbd_io_checker.data_flow_analysis_st(Path(fr'.\exports\st\{Path(src).name}_{bwd}_{formal}_{iec_check}_{st_parser}_{impact_analysis}.st'))
